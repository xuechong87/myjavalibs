<对共享可变数据的访问同步>
	*为了提高性能,在读或写原子数据的时候,应该避免同步:这个建议是非常危险而错误的
	*为了在线程之间可靠的通信,以及为了互斥访问,同步是需要的
		关于java 内存模型(memory model):
			可在线程之间共享的内存叫做共享内存,或者 堆内存
	*无论何时当多个线程共享可变数据的时候,每个读或者写数据的线程必须获得一把锁
		不要由于原子读和写而妨碍你执行正确的同步.如果没有同步,则一个线程所做的修改
		就无法保证被另一个线程观察到.未被同步的数据访问会造成程序的活性失败(liveness failure)
		和安全性失败(safety failure) 而且这样的失败将会难以重现
		他们可能是时间相关的,可能会高度依赖JVM的实现细节以及所运行的硬件平台
<避免过多的同步>
	*为了避免死锁的危险,在一个被同步的方法或者代码块中,永远不要放弃对客户的控制.
		换句话说,在一个被同步的区域内部不要调用一个可被改写的共有方法或受保护的方法
<不要依赖于线程调度器>
	*任何依赖于线程调度器而达到正确性或性能要求的程序,很可能是不可移植的.
	*不要企图通过Thread.yield来"修正"程序,这样的程序是不可移植的,其性能表现依赖于JVM的实现
	*线程优先级是JAVA平台上最不可移植的特征
	*对于大多数程序员来说,Thread.yield唯一的用途是在测试期间人为的增加一个程序的并发性了