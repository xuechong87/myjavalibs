异常
<只针对不正常的条件才使用异常>
	*异常只应该使用于不正常的条件,他们永远不应该被用于正常的控制流
	*一个良好设计的API不应该强迫它的客户为了正常的控制流而使用异常

<对于可恢复的条件使用被检查的异常,对于程序错误使用运行时异常>
	*如果期望调用者能够恢复,那么对于这样的条件应选择被检查的异常
	*用运行时异常来指明程序错误
	*你所实现的所有的未被检查的抛出结构都应该是RuntimeException的子类

<避免不必要的使用被检查异常>

<尽量使用标准的异常>

<抛出的异常要适合于响应的抽象>
	*高层的实现应该捕获低层的异常,同时抛出一个可以按照高层抽象进行解释的异常
	*异常链接:如果低层的异常对于调试该异常被抛出的情形非常有帮助,
		那么使用异常链接是很合适的.
	*尽管异常转译比不加选择的传递低层异常的做法有所改进,但是它不能被滥用
	
<努力使失败保持原子性>
	*一般而言,一个失败的方法调用应该使对象保持'它在被调用之前的状态'.
		具有这种属性的方法被称为具有^失败原子性^(failure atomic)
	*实现失败原子性的方法:
		1)设计一个非可变对象
		2)在执行操作之前检查参数的有效性;
			或者对计算处理调整顺序,使得任何可能会失败的计算部分都发生在对象状态被修改之前
		3)编写一段恢复代码(recovery code),
			由他来解释操作过程中发生的失败,以及使对象回滚到开始之前的状态上
			这种办法主要用于永久性的数据结构
		4)在对象的一份临时copy上执行操作,当操作完成之后再把临时拷贝的结果复制给原来的对象
	