<可被继承的类的设计>:为了继承而设计一个类,要求对这个类有一些实质性的限制
	为了允许类被继承,一个类必须遵守一些约束:
		*构造函数一定不能调用可被改写的方法,无论是直接还是间接进行.
		 超类的构造函数在子类的构造函数之前运行,所以子类中改写版本的方法会在子类的构造函数运行之前就
		 先被调用.
		*如果一个类实现了Cloneable或者Serializable接口,
		 无论是clone方法还是readObject方法,
		 都不能调用一个可被改写的方法,不论是直接还是间接
		 必须使readResolve或者writeReplace成为protected方法,
		 而不是private方法.如果这些方法是私有的,那么子类将会
		 不声不响的忽略掉这两个方法.

<接口优于抽象类>
	 *已有的类可以很容易被更新,以使其实现新的接口
	 *接口是定义mixin(混合类型)的理想选择:
		mixin:一个雷出了实现它的'基本类型'之外,还可以实现一个mixin类型
			以表明它提供了某些可供选择的行为
	 *接口使得我们可以构造出非层次结构的类型框架
	 *接口使得安全地增强一个类的功能成为可能
	 *你可以把接口和抽象类的有点结合起来,对于你期望导出的每一个重要接口
	  都提供一个抽象的^骨架实现(skeletal implementation)^类
	 &&抽象类的演化比接口的演化要容易得多:在抽象类中增加一个新的方法,
		那么,你总是可以增加一个具体的方法,它包含了一个合理的默认实现.
		该抽象类的所有已有的实现都自动提供了这个新的方法.
		而对于接口,这样做是行不通的
		
<优先考虑静态成员类>
	如果你声明的成员类不要求访问外围实例,那么请记住把static修饰符放到成员类的声明中
	使它成为一个静态成员类,而不是一个非静态成员类.
	如果省略了static修饰符,则每个实例都将包含一个额外的指向外围对象的引用.(浪费空间和时间) 
	
<谨慎设计方法的原型>
	*谨慎选择方法的名字
	*不要过于追求提供便利的方法,只有一个操作被用得非常频繁才考虑为它提供一个快捷方法(shorthand)
		如果不能确定的话还是不考虑为好
	*避免过长的参数列表,类型相同的长参数列表尤其有害
	*对于参数类型,优先使用接口而不是类
	*谨慎得使用函数对象
